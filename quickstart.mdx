---
title: "Quickstart"
description: "Get started with Parsecular in 5 minutes"
---

## Prerequisites

Before you begin, ensure you have:

- **Rust 1.70+** installed ([rustup.rs](https://rustup.rs))
- **Tokio** runtime for async support
- API credentials for the exchange(s) you want to use

## Installation

<Steps>
  <Step title="Add Dependencies">
    Add Parsecular crates to your `Cargo.toml`:

    ```toml
    [dependencies]
    # Core library (required)
    pc-core = { path = "pc-core" }

    # Add exchange implementations you need
    pc-exchange-polymarket = { path = "pc-exchange-polymarket" }
    pc-exchange-limitless = { path = "pc-exchange-limitless" }
    pc-exchange-kalshi = { path = "pc-exchange-kalshi" }
    pc-exchange-opinion = { path = "pc-exchange-opinion" }
    pc-exchange-predictfun = { path = "pc-exchange-predictfun" }

    # Required dependencies
    tokio = { version = "1", features = ["full"] }
    anyhow = "1"
    ```
  </Step>

  <Step title="Set Environment Variables">
    Configure your API credentials. Each exchange requires different environment variables:

    <Tabs>
      <Tab title="Polymarket">
        ```bash
        export POLYMARKET_PRIVATE_KEY="0x..."
        export POLYMARKET_FUNDER="0x..."
        ```
      </Tab>
      <Tab title="Limitless">
        ```bash
        export LIMITLESS_PRIVATE_KEY="0x..."
        ```
      </Tab>
      <Tab title="Kalshi">
        ```bash
        export KALSHI_API_KEY_ID="your-api-key-id"
        export KALSHI_PRIVATE_KEY_PATH="/path/to/private-key.pem"
        ```
      </Tab>
      <Tab title="Opinion">
        ```bash
        export OPINION_API_KEY="your-api-key"
        export OPINION_PRIVATE_KEY="0x..."
        export OPINION_MULTI_SIG_ADDR="0x..."
        ```
      </Tab>
      <Tab title="Predict.fun">
        ```bash
        export PREDICTFUN_API_KEY="your-api-key"
        export PREDICTFUN_PRIVATE_KEY="0x..."
        ```
      </Tab>
    </Tabs>

    <Note>
      Authentication is only required for trading operations. You can fetch public market data without credentials.
    </Note>
  </Step>

  <Step title="Write Your First Program">
    Create a simple program to fetch markets:

    ```rust
    use pc_core::{Exchange, FetchMarketsParams};
    use pc_exchange_polymarket::{Polymarket, PolymarketConfig};

    #[tokio::main]
    async fn main() -> anyhow::Result<()> {
        // Initialize the exchange (no auth needed for public data)
        let config = PolymarketConfig::new();
        let exchange = Polymarket::new(config)?;

        // Print exchange info
        println!("Connected to: {} ({})", exchange.name(), exchange.id());

        // Fetch active markets
        let markets = exchange
            .fetch_markets(Some(FetchMarketsParams {
                limit: Some(5),
                active_only: true,
            }))
            .await?;

        // Display markets
        for market in markets {
            println!("\n─────────────────────────────────");
            println!("ID:       {}", market.id);
            println!("Question: {}", market.question);
            println!("Outcomes: {}", market.outcomes.join(" vs "));

            // Show prices
            for (outcome, price) in &market.prices {
                println!("  {}: {:.1}%", outcome, price * 100.0);
            }

            println!("Volume:    ${:.0}", market.volume);
            println!("Liquidity: ${:.0}", market.liquidity);
        }

        Ok(())
    }
    ```
  </Step>

  <Step title="Run the Program">
    ```bash
    cargo run
    ```

    You should see output like:
    ```
    Connected to: Polymarket (polymarket)

    ─────────────────────────────────
    ID:       0x1234...
    Question: Will Bitcoin reach $100k by end of 2024?
    Outcomes: Yes vs No
      Yes: 65.2%
      No: 34.8%
    Volume:    $1,234,567
    Liquidity: $456,789
    ```
  </Step>
</Steps>

## Common Operations

### Fetch a Single Market

```rust
let market = exchange.fetch_market("market-id-here").await?;
println!("Question: {}", market.question);
```

### Create an Order (Requires Authentication)

```rust
use pc_core::OrderSide;
use std::collections::HashMap;

// Configure with credentials
let config = PolymarketConfig::new()
    .with_private_key("0x...")
    .with_funder("0x...");
let exchange = Polymarket::new(config)?;

// Place a buy order
let order = exchange
    .create_order(
        "market-id",      // market ID
        "Yes",            // outcome
        OrderSide::Buy,   // side
        0.65,             // price (65 cents)
        100.0,            // size (100 shares)
        HashMap::new(),   // additional params
    )
    .await?;

println!("Order placed: {}", order.id);
println!("Status: {:?}", order.status);
```

### Fetch Your Positions

```rust
let positions = exchange.fetch_positions(None).await?;

for pos in positions {
    println!(
        "{} - {}: {} shares @ ${:.2}",
        pos.market_id, pos.outcome, pos.size, pos.average_price
    );
    println!("  P&L: ${:.2} ({:.1}%)",
        pos.unrealized_pnl(),
        pos.unrealized_pnl_percent()
    );
}
```

### Check Your Balance

```rust
let balance = exchange.fetch_balance().await?;

for (asset, amount) in balance {
    println!("{}: ${:.2}", asset, amount);
}
```

## Multi-Exchange Example

One of Parsecular's key features is the ability to work with multiple exchanges using the same interface:

```rust
use pc_core::{Exchange, FetchMarketsParams};
use pc_exchange_polymarket::{Polymarket, PolymarketConfig};
use pc_exchange_limitless::{Limitless, LimitlessConfig};
use pc_exchange_kalshi::{Kalshi, KalshiConfig};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Create multiple exchanges
    let polymarket = Polymarket::new(PolymarketConfig::new())?;
    let limitless = Limitless::new(LimitlessConfig::new())?;
    let kalshi = Kalshi::new(KalshiConfig::demo())?;

    // Use the same interface for all
    let exchanges: Vec<Box<dyn Exchange>> = vec![
        Box::new(polymarket),
        Box::new(limitless),
        Box::new(kalshi),
    ];

    for exchange in exchanges {
        println!("\n=== {} ===", exchange.name());

        let markets = exchange
            .fetch_markets(Some(FetchMarketsParams {
                limit: Some(3),
                active_only: true,
            }))
            .await?;

        for market in markets {
            println!("  {} - {}", market.id, market.question);
        }
    }

    Ok(())
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Exchange Setup" icon="building-columns" href="/exchanges/overview">
    Learn about each exchange's specific features and configuration.
  </Card>
  <Card title="Data Models" icon="database" href="/models/market">
    Understand the Market, Order, Position, and Orderbook models.
  </Card>
  <Card title="WebSocket Streaming" icon="signal" href="/websocket/overview">
    Stream real-time orderbook data.
  </Card>
  <Card title="Strategy Framework" icon="chart-line" href="/strategy/overview">
    Build automated trading strategies.
  </Card>
</CardGroup>
